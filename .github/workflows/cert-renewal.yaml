name: cert-renewal
on:
  workflow_call:
    inputs:
      CERT_CONTACT_EMAIL:
        description: 'Email will be sent when cert almost expired'
        type: string
        required: true
      CERT_STAGING:
        description: 'True or False'
        type: string
        required: true
        default: 'True'
      ROUTE53_ZONE_NAME:
        description: 'Route53 Hosted Zone name'
        type: string
        required: true
      ROUTE53_RECORD_NAME:
        description: 'Route53 record name'
        type: string
        required: true
      MANUAL_LETSENCRYPT_REPO:
        description: 'manual-letsencrypt repo useful to work with dev fork'
        type: string
        default: 'https://github.com/datajoint/manual-letsencrypt.git'
      MANUAL_LETSENCRYPT_BRANCH:
        description: 'manual-letsencrypt repo useful to work with dev branch'
        type: string
        default: 'master'
      CALLER_REPO_SUBPATH_FOR_CERT:
        description: 'a subpath in the caller repo to store the cert'
        type: string
      PR_REVIEWERS:
        description: 'comma separated list of github usernames'
        type: string
    secrets:
      ROUTE53_ZONE_ID:
        description: 'Route53 Hosted Zone ID'
        required: true
      INSTANCE_VPC_SECURITY_GROUP_IDS:
        required: true
      INSTANCE_SUBNET_ID:
        required: true
      AWS_DEFAULT_REGION:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SSH_PRIVATE_KEY:
        description: 'ssh private key to access the instance in base64 encoded'
        required: true

jobs:
  cert-renewal:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller-repo
      - name: Checkout manual-letsencrypt
        uses: actions/checkout@v4
        with:
          github-server-url: ${{inputs.MANUAL_LETSENCRYPT_REPO}}
          ref: refs/remotes/origin/${{inputs.MANUAL_LETSENCRYPT_BRANCH}}
          path: manual-letsencrypt
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Run terraform, get cert, and make PR
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ inputs.AWS_DEFAULT_REGION }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ## make ssh private key file in $GITHUB_WORKSPACE and chmod 400
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 -d > $GITHUB_WORKSPACE/ssh_private_key
          chmod 400 $GITHUB_WORKSPACE/ssh_private_key
          ls -lah $GITHUB_WORKSPACE

          cd $GITHUB_WORKSPACE/manual-letsencrypt/terraform
          echo "instance_vpc_security_group_ids = ${{inputs.INSTANCE_VPC_SECURITY_GROUP_IDS}}" >> input.tfvars
          echo "instance_subnet_id = ${{inputs.INSTANCE_SUBNET_ID}}" >> input.tfvars
          echo "cert_contact_email = ${{inputs.CERT_CONTACT_EMAIL}}" >> input.tfvars
          echo "cert_staging = ${{inputs.CERT_STAGING}}" >> input.tfvars
          echo "route53_zone_id = ${{inputs.ROUTE53_ZONE_ID}}" >> input.tfvars
          echo "route53_zone_name = ${{inputs.ROUTE53_ZONE_NAME}}" >> input.tfvars
          echo "route53_record_name = ${{inputs.ROUTE53_RECORD_NAME}}" >> input.tfvars
          cat input.tfvars
          terraform init
          # terraform apply -auto-approve -var-file=input.tfvars
          # ## get the instance public ip
          # INSTANCE_PUBLIC_IP=$(terraform output -raw auto-letsencrypt-instance-public-ip)
          # ## check if the cert is ready
          # time=0
          # while [ $(ssh -i $GITHUB_WORKSPACE/ssh_private_key ubuntu@$INSTANCE_PUBLIC_IP "cloud-init status") != "status: done" ]
          # do
          #   sleep 60
          #   time=$((time+60))
          #   echo "INFO :: Waiting for SSL certs to be generated. Time elapsed: $${time} seconds"
          #   if [ $${time} -gt 900 ]; then
          #     echo "ERROR :: Timeout waiting for SSL certs to be generated on $INSTANCE_PUBLIC_IP"
          #     ssh -i $GITHUB_WORKSPACE/ssh_private_key ubuntu@$INSTANCE_PUBLIC_IP "cat /var/log/cloud-init-output.log"
          #     exit 1
          #   fi
          # done
          # ## get the generated cert
          # scp -i $GITHUB_WORKSPACE/ssh_private_key \
          #   ubuntu@$INSTANCE_PUBLIC_IP:/manual-letencrypt/letsencrypt/letsencrypt-keys/live/"{fullchain.pem,prikey.pem}" \
          #   $GITHUB_WORKSPACE/caller-repo/${{inputs.CALLER_REPO_SUBPATH_FOR_CERT}}
          # terraform destroy -auto-approve -var-file=input.tfvars

          # cd $GITHUB_WORKSPACE/caller-repo
          # git config --global user.email "github-actions[bot]@users.noreply.github.com"
          # git config --global user.name "github-actions[bot]"
          # NEW_BRANCH=cert-update-$(date '+%Y-%m-%d')
          # git switch -c $NEW_BRANCH
          # git add .
          # git status
          # git commit -m "Update cert $(date '+%Y-%m-%d')"
          # git push
          # ## make a PR
          # gh pr create -b master -H $NEW_BRANCH \
          #   --title "Update cert $(date '+%Y-%m-%d')" --body "Update cert $(date '+%Y-%m-%d')" \
          #   --reviewer ${{inputs.PR_REVIEWERS}}

      
